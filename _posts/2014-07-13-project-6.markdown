---
layout: default
modal-id: 6
title: A* Path Finders
short-caption: A* Path Finders
date: 2020-01-04
img: A_star.gif
alt: image-alt
project-date: December 2019
client: Start Bootstrap
category: A* algorithm, Robotics Navigation
description: <br><br><p> A* is the most popular choice for pathfinding, because it’s fairly flexible and can be used in a wide range of contexts. The secret to its success is that it combines the pieces of information that Dijkstra’s Algorithm uses (favoring vertices that are close to the starting point) and information that Greedy Best-First-Search uses (favoring vertices that are close to the goal). In the standard terminology used when talking about A*, g(n) represents the exact cost of the path from the starting point to any vertex n, and h(n) represents the heuristic estimated cost from vertex n to the goal. </p> <br><br><p>Imagine we have the (h) represents vertices far from the goal and (g) represents vertices far from the starting point. A* balances the two as it moves from the starting point to the goal. Each time through the main loop, it examines the vertex n that has the lowest <b>true cost</b> f(n) = g(n) + h(n). Therefore, A* algorithm uses both the actual distance from the start and the estimated distance to the goal.</p> <br><br><p>A* will find the shortest path by repeating the following steps:<ol><li>Get the cell S on the open list which has the lowest true cost.</li><li>Remove S from the open list and add S to the closed list.</li><li>For each square T in S’s walkable adjacent 8 tiles, <ul><li>If T is in the closed list, Ignore it.</li><li>If T is not in the open list, Add it and compute its score.</li><li>If T is already in the open list, Check if the F score is lower when we use the current generated path to get there. If it is, update its score and update its parent as well.</li></ul></li></ol></p> <p>The heuristic function I use is <br><center><img src="https://user-images.githubusercontent.com/39393023/72273917-daf2f480-35f0-11ea-94c4-ec4f833c11f9.png" alt="Log Yard" width="250" ></center></p><br><br><p><b>A note on online A*</b> - The term online indicates that a map is not known before hand and only the nodes that are neighboring to the current node are known and the rest of the map is unexplored. In such scenarios, where backtracking is prohibited or extremely costly, a fast data structure that quickly sorts the open list and returns the node with lowest true cost is very desirable. In my implementation, I used Python's heap queue for that purpose.</p><br><br><p>For more details, please check out my <a href="https://drive.google.com/file/d/1nq-4ucO8FdCAWpOvyA_0U50_1RAMwJUC/view?usp=sharing">report for this project</a>, my <a href="https://github.com/RicoJia/A-Star-Path-Finding-Algorithms-with-P-Motion-Control">Github Repo</a> or  <a href="index.html">shoot me a message!</a></p>
---
